//ç»™ä½ ä¸€ä¸ªé“¾è¡¨å’Œä¸€ä¸ªç‰¹å®šå€¼ x ï¼Œè¯·ä½ å¯¹é“¾è¡¨è¿›è¡Œåˆ†éš”ï¼Œä½¿å¾—æ‰€æœ‰å°äºŽ x çš„èŠ‚ç‚¹éƒ½å‡ºçŽ°åœ¨å¤§äºŽæˆ–ç­‰äºŽ x çš„èŠ‚ç‚¹ä¹‹å‰ã€‚
//
// ä½ åº”å½“ä¿ç•™ä¸¤ä¸ªåˆ†åŒºä¸­æ¯ä¸ªèŠ‚ç‚¹çš„åˆå§‹ç›¸å¯¹ä½ç½®ã€‚
//
//
//
// ç¤ºä¾‹ï¼š
//
//
//è¾“å…¥ï¼šhead = 1->4->3->2->5->2, x = 3
//è¾“å‡ºï¼š1->2->2->4->3->5
//
// Related Topics é“¾è¡¨ åŒæŒ‡é’ˆ
// ðŸ‘ 345 ðŸ‘Ž 0


//leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *partition(ListNode *head, int x) {
        ListNode *smallHead = new ListNode(0);
        ListNode *small = smallHead;
        ListNode *largeHead = new ListNode(0);
        ListNode *large = largeHead;
        while (head) {
            if (head->val < x) {
                small->next = head;
                small = small->next;
            } else {
                large->next = head;
                large = large->next;
            }
            head = head->next;
        }
        large->next = nullptr;
        small->next = largeHead->next;
        return smallHead->next;
    }
};
//leetcode submit region end(Prohibit modification and deletion)
