//åœ¨æœ¬é—®é¢˜ä¸­ï¼Œæœ‰æ ¹æ ‘æŒ‡æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æœ‰å‘å›¾ã€‚è¯¥æ ‘åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œæ‰€æœ‰å…¶ä»–èŠ‚ç‚¹éƒ½æ˜¯è¯¥æ ¹èŠ‚ç‚¹çš„åç»§ã€‚æ¯ä¸€ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œé™¤äº†æ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶èŠ‚ç‚¹ã€‚
//
// è¾“å…¥ä¸€ä¸ªæœ‰å‘å›¾ï¼Œè¯¥å›¾ç”±ä¸€ä¸ªæœ‰ç€Nä¸ªèŠ‚ç‚¹ (èŠ‚ç‚¹å€¼ä¸é‡å¤1, 2, ..., N) çš„æ ‘åŠä¸€æ¡é™„åŠ çš„è¾¹æ„æˆã€‚é™„åŠ çš„è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹åŒ…å«åœ¨1åˆ°Nä¸­é—´ï¼Œè¿™æ¡é™„åŠ çš„è¾¹
//ä¸å±äºæ ‘ä¸­å·²å­˜åœ¨çš„è¾¹ã€‚
//
// ç»“æœå›¾æ˜¯ä¸€ä¸ªä»¥è¾¹ç»„æˆçš„äºŒç»´æ•°ç»„ã€‚ æ¯ä¸€ä¸ªè¾¹ çš„å…ƒç´ æ˜¯ä¸€å¯¹ [u, v]ï¼Œç”¨ä»¥è¡¨ç¤ºæœ‰å‘å›¾ä¸­è¿æ¥é¡¶ç‚¹ u å’Œé¡¶ç‚¹ v çš„è¾¹ï¼Œå…¶ä¸­ u æ˜¯ v çš„ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ã€‚
//
//
// è¿”å›ä¸€æ¡èƒ½åˆ é™¤çš„è¾¹ï¼Œä½¿å¾—å‰©ä¸‹çš„å›¾æ˜¯æœ‰Nä¸ªèŠ‚ç‚¹çš„æœ‰æ ¹æ ‘ã€‚è‹¥æœ‰å¤šä¸ªç­”æ¡ˆï¼Œè¿”å›æœ€åå‡ºç°åœ¨ç»™å®šäºŒç»´æ•°ç»„çš„ç­”æ¡ˆã€‚
//
// ç¤ºä¾‹ 1:
//
// è¾“å…¥: [[1,2], [1,3], [2,3]]
//è¾“å‡º: [2,3]
//è§£é‡Š: ç»™å®šçš„æœ‰å‘å›¾å¦‚ä¸‹:
//  1
// / \
//v   v
//2-->3
//
//
// ç¤ºä¾‹ 2:
//
// è¾“å…¥: [[1,2], [2,3], [3,4], [4,1], [1,5]]
//è¾“å‡º: [4,1]
//è§£é‡Š: ç»™å®šçš„æœ‰å‘å›¾å¦‚ä¸‹:
//5 <- 1 -> 2
//     ^    |
//     |    v
//     4 <- 3
//
//
// æ³¨æ„:
//
//
// äºŒç»´æ•°ç»„å¤§å°çš„åœ¨3åˆ°1000èŒƒå›´å†…ã€‚
// äºŒç»´æ•°ç»„ä¸­çš„æ¯ä¸ªæ•´æ•°åœ¨1åˆ°Nä¹‹é—´ï¼Œå…¶ä¸­ N æ˜¯äºŒç»´æ•°ç»„çš„å¤§å°ã€‚
//
// Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¶æŸ¥é›† å›¾
// ğŸ‘ 176 ğŸ‘ 0


//leetcode submit region begin(Prohibit modification and deletion)

class Solution {
private:
    vector<int> ancestor;//è®°å½•èŠ‚ç‚¹çš„ç¥–å…ˆ
    int n;               // è¾¹çš„æ•°é‡
    // å¹¶æŸ¥é›†åˆå§‹åŒ–
    void init() {
        ancestor.resize(n + 1);
        for (int i = 1; i <= n; ++i) {
            ancestor[i] = i;
        }
    }

    // å¹¶å·®ä»·æŸ¥æ‰¾æ ¹èŠ‚ç‚¹
    int find(int u) {
        return u == ancestor[u] ? u : ancestor[u] = find(ancestor[u]);
    }

    // å°†[u,v]è¿™æ¡è¾¹åŠ å…¥å¹¶æŸ¥é›†
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u != v) {
            ancestor[v] = u;
        }
    }

    // åˆ¤æ–­ u å’Œ væ˜¯æœ‰ç›¸åŒæ ¹èŠ‚ç‚¹
    bool same(int u, int v) {
        return find(u) == find(v);
    }

    // åˆ ä¸€æ¡è¾¹ä¹‹ååˆ¤æ–­æ˜¯ä¸æ˜¯æ ‘
    bool isTreeAfterRemoveEdge(const vector<vector<int>> &edges, int deleteEdge) {
        init();// åˆå§‹åŒ–å¹¶æŸ¥é›†
        for (int i = 0; i < n; i++) {
            if (i == deleteEdge) continue;
            if (same(edges[i][0], edges[i][1])) {// æ„æˆæœ‰å‘ç¯ï¼Œä¸€å®šä¸æ˜¯æ ‘
                return false;
            }
            join(edges[i][0], edges[i][1]);
        }
        return true;
    }

    // åœ¨æœ‰å‘å›¾é‡Œæ‰¾åˆ°åˆ é™¤çš„é‚£æ¡è¾¹ï¼Œä½¿å…¶å˜æˆæ ‘
    vector<int> getRemoveEdge(const vector<vector<int>> &edges) {
        init();                                  // åˆå§‹åŒ–å¹¶æŸ¥é›†
        for (int i = 0; i < n; i++) {            // éå†æ‰€æœ‰çš„è¾¹
            if (same(edges[i][0], edges[i][1])) {// æ„æˆæœ‰å‘ç¯äº†ï¼Œå°±æ˜¯è¦åˆ é™¤çš„è¾¹
                return edges[i];
            }
            join(edges[i][0], edges[i][1]);
        }
        return {};
    }

public:
    vector<int> findRedundantDirectedConnection(vector<vector<int>> &edges) {
        n = edges.size();   // è¾¹çš„æ•°é‡
        int inDegree[n + 1];// è®°å½•èŠ‚ç‚¹å…¥åº¦
        memset(inDegree, 0, sizeof(inDegree));
        for (int i = 0; i < n; i++) {
            inDegree[edges[i][1]]++;// ç»Ÿè®¡å…¥åº¦
        }
        vector<int> vec;// è®°å½•å…¥åº¦ä¸º2çš„è¾¹çš„åºå·ï¼ˆ2æ¡è¾¹ï¼‰
        // æ‰¾å…¥åº¦ä¸º2çš„èŠ‚ç‚¹æ‰€å¯¹åº”çš„è¾¹ï¼Œæ³¨æ„è¦å€’å™ï¼Œå› ä¸ºä¼˜å…ˆè¿”å›æœ€åå‡ºç°åœ¨äºŒç»´æ•°ç»„ä¸­çš„ç­”æ¡ˆ
        for (int i = n - 1; i >= 0; i--) {
            if (inDegree[edges[i][1]] == 2) {
                vec.push_back(i);
            }
        }
        // å¦‚æœæœ‰å…¥åº¦ä¸º2çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä¸€å®šæ˜¯å¯¹åº”ä¸¤æ¡è¾¹åˆ ä¸€æ¡ï¼Œé€‰æ‹©åˆ é™¤åæ„æˆæ ‘çš„è¾¹
        if (vec.size() > 0) {
            if (isTreeAfterRemoveEdge(edges, vec[0])) {
                return edges[vec[0]];
            } else {
                return edges[vec[1]];
            }
        }
        // å¦‚æœæ²¡æœ‰å…¥åº¦ä¸º2çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä¸€å®šå­˜åœ¨æœ‰å‘ç¯ï¼Œåˆ é™¤ç¯è·¯ä¸­æœ€åä¸€æ¡è®¿é—®çš„è¾¹
        return getRemoveEdge(edges);
    }
};
//leetcode submit region end(Prohibit modification and deletion)